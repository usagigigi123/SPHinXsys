#pragma once

#include <iostream>
#include <iomanip>
#include <vector>

//======================================================================

// Returns interpolated value at x from parallel arrays ( xData, yData )
//   Assumes that xData has at least two elements, is sorted and is strictly monotonic increasing
//   boolean argument extrapolate determines behaviour beyond ends of array (if needed)

std::vector<double> xData = {0.0, 0.00299646, 0.0396642 , 0.08483057, 0.13427018, 0.14985097,
       0.15838949, 0.16413504, 0.1741259 , 0.18264048, 0.20668398,
       0.20960064, 0.22660985, 0.2393897 , 0.24373476, 0.2494444 ,
       0.25656249, 0.26365265, 0.2735278 , 0.28345882, 0.29188961,
       0.29753939, 0.30597417, 0.32149512, 0.33271489, 0.34534312,
       0.35241333, 0.36919112, 0.39022619, 0.41829158, 0.43651373,
       0.43646186, 0.45469199, 0.47715548, 0.48422569, 0.49969078,
       0.51085469, 0.53046934, 0.55291686, 0.58097028, 0.60342977,
       0.62732964, 0.64555578, 0.64974923, 0.68490478, 0.72145282,
       0.75520391, 0.77770729, 0.79459679, 0.82554293, 0.84382893,
       0.8691971 , 0.88890751, 0.90579302, 0.95228006, 0.99736663, 1.0};
std::vector<double> yData = {0.0, 1.41444127e-02,  6.96108591e-01,  2.05844096e+00,  4.10090213e+00,
        5.34824382e+00,  6.59518651e+00,  8.18191430e+00,  1.00521687e+01,
        1.09591667e+01,  1.23769596e+01,  1.37935554e+01,  1.53242642e+01,
        1.67980760e+01,  1.84980389e+01,  1.95748497e+01,  2.06517402e+01,
        2.13320286e+01,  2.15592170e+01,  2.25796097e+01,  2.22968012e+01,
        2.25237502e+01,  2.22975992e+01,  2.26950792e+01,  2.20158282e+01,
        2.13366570e+01,  2.17336581e+01,  1.99782348e+01,  1.86763104e+01,
        1.72048127e+01,  1.59593862e+01,  1.52228393e+01,  1.40907277e+01,
        1.30721704e+01,  1.34691716e+01,  1.30734472e+01,  1.16009919e+01,
        1.01290154e+01,  8.88382829e+00,  7.24235823e+00,  6.16714347e+00,
        5.54526811e+00,  4.35649905e+00,  3.90347885e+00,  3.11226953e+00,
        2.09451021e+00,  1.35987855e+00,  9.07895734e-01,  7.38880975e-01,
        1.74062060e-01, 0.,  6.32209361e-02, 0.,
       0., 0.,  7.04826656e-02, 0.0};

double interpolate(double x)
{
   int size = xData.size();
   int i = 0;                                                                  // find left end of interval for interpolation
   if ( x >= xData[size - 2] )                                                 // special case: beyond right end
   {
      i = size - 2;
   }
   else
   {
      while ( x > xData[i+1] ) i++;
   }
   double xL = xData[i], yL = yData[i], xR = xData[i+1], yR = yData[i+1];      // points on either side (unless beyond ends)

   double dydx = ( yR - yL ) / ( xR - xL );                                    // gradient

   return yL + dydx * ( x - xL );                                              // linear interpolation
}

//======================================================================